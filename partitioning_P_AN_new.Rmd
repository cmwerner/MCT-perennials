---
title: "partitioning_P_AN_new"
output: html_document
---
---
title: "Partitioning perennial - nonseedbank annual"
output: html_document
---

Goal is to look at the strength of the storage effect in perennial (P) and nonseedbanking annual (AN) species interactions. We want to measure how the storage effect [and the relative strength of storage effect:relative nonlinearity] changes with 1. magnitude of envrionmental variation 2. autocorrelation of environmental variation

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

## Personal ggplot theme
theme_cw <- function () { 
  theme_bw(base_size=12) %+replace% 
    theme(
      panel.background = element_blank(), 
      plot.background = element_blank(), 
      axis.ticks = element_line(colour = "grey70", size = rel(0.5)),
      panel.grid.minor = element_blank(), 
      panel.grid.major.x = element_blank(),
      legend.background = element_blank(), 
      legend.key = element_blank(),
      strip.background = element_blank(), 
      #  strip.text=element_text(size=12),
      #  axis.text=element_text(size=12),
      complete = TRUE
    )
}
```

## Parameters and set up
Setting parameters we're going to use for alpha and lambda under different environmental conditions. 

```{r parameters}
# main parameters
pars <- read.csv('model_parameters_perennials.csv') %>%
  mutate(seed.surv = NULL)

# adding average values to the parameter df
an.means <- pars %>%
  filter(species == 'an') %>% 
  select(a.an, a.s, a.p, lambda, seed.germ) %>%
  colMeans()
s.means <- pars %>%
  filter(species == 's') %>% 
  select(a.an, a.s, a.p, seed.germ, stem.surv) %>%
  colMeans()
p.means <- pars %>%
  filter(species == 'p') %>%
  select(a.an, a.s, a.p, lambda, stem.surv) %>%
  colMeans()

pars <- pars %>%
  add_row(treatment = 'average', species = 'an', 
          a.an = an.means['a.an'], a.s = an.means['a.s'], a.p = an.means['a.p'],
          lambda = an.means['lambda'], seed.germ = an.means['seed.germ'], 
          stem.surv = NA) %>%
  add_row(treatment = 'average', species = 's', 
          a.an = s.means['a.an'], a.s = s.means['a.s'], a.p = s.means['a.p'],
          lambda = NA, seed.germ = s.means['seed.germ'], 
          stem.surv = s.means['stem.surv']) %>%
  add_row(treatment = 'average', species = 'p', 
          a.an = p.means['a.an'], a.s = p.means['a.s'], a.p = p.means['a.p'],
          lambda = p.means['lambda'], seed.germ = NA, 
          stem.surv = p.means['stem.surv'])

```

Functions for one step of species interaction calculations. Trying to make it general to whether it's both species present or just one--if it's one, that population is just at 0. Takes in the full parameter df for all the species (just for one environmental condition though) and a list of species population sizes. If it's just one species running to equilibrium then it's N0 will be 0. *Goal for making this more modular would be to have an analog of this function for the annual-seedbanking species*
```{r species-interactions}
pop_interactions <- function(N0, param){
  pars.s <- param %>% filter(species == 's')
  pars.p <- param %>% filter(species == 'p')
  pars.an <- param %>% filter(species == 'an')
  
  n.s <- N0$p*pars.p$lambda /
    (1 + pars.p$a.an * pars.an$seed.germ * N0$an +
       pars.p$a.s * pars.s$seed.germ * N0$s +
       pars.p$a.p * N0$p)
  
  n.p <- N0$p * pars.p$stem.surv +
    (N0$s * pars.s$seed.germ * pars.s$stem.surv) /
    (1 + pars.s$a.an * pars.an$seed.germ * N0$an +
       pars.s$a.s * pars.s$seed.germ * N0$s +
       pars.s$a.p * N0$p)
  
  n.an <- N0$an * pars.an$seed.germ *pars.an$lambda /
    (1+ pars.an$a.an * pars.an$seed.germ * N0$an +
       pars.an$a.s * pars.s$seed.germ * N0$s +
       pars.an$a.p * N0$p)
  
  n.all <- tibble(an = n.an,
                  s = n.s,
                  p = n.p)
  return(n.all)
}

```

## Running models

Not sure if we can use the same function to run an invasion as before or not. It would be nice to set this up to work somehow, but it may need to reworked to be about the perennial vs the annual rather than the resident vs invader, and just use their ids to determine what the populations should be? 

Idea is that sp.invader and sp.resident parameters can be either a single value (ex: 'a') or multiple values (ex: c('s','p'))
```{r running-invasion}
run_invasion <- function(sp.invader, sp.resident, N0.r, parameters, env.cond,
                         vary.lambda = TRUE, vary.alpha = TRUE, 
                         init.time.steps = 50, total.time.steps = 100) {
  
  
  # populations with resident species not impacted by the invader
  # NOTE: this isn't generic to any invader and resident species names
  n.all <- tibble(an = as.numeric(rep(NA, total.time.steps)),
                  s = as.numeric(rep(NA, total.time.steps)),
                  p = as.numeric(rep(NA, total.time.steps)))
  
  # setting initial populations
  n.all[1,sp.resident] <- N0.r
  n.all[1,sp.invader] <- 0
  
  # name of column(s) for resident species pop when impacted by invading pop
  sp.res.impact <- paste(sp.resident, 'impact', sep = '.')
  
  
  # parameters for the average env condition
  p.ave <- parameters %>% filter(treatment == 'average')
  for(t in 1:init.time.steps){
    # parameters for the varying env condition
    p.env <- parameters %>% filter(treatment == env.cond[t])
    
    # setting non-varying parameters to their average
    if(vary.lambda == FALSE){
      p.env$lambda <- p.ave$lambda
    }
    
    # NOTE not sure if this is working yet
    if(vary.alpha == FALSE){
      alpha.columns <- c(paste('a', sp.invader, sep = '.'), paste('a', sp.resident, sep = '.'))
      p.env[,alpha.columns] <- p.ave[,alpha.columns]
    }
    
    # running one time step with the appropriate environmental parameters
    n.all[t+1,] <- pop_interactions(N0 = n.all[t,], param = p.env)
    
  }
  
  # figuring out rough invader population distribution if the invader is perennial
  # using average parameters and resident population size during the final warm-up step
  # makes it faster for running in for loop
  if(length(sp.invader) > 1) {
    n.inv.start <- 1/length(sp.invader)
    n.old <- n.all[init.time.steps,]
    n.old[sp.invader] <- n.inv.start
    n.old.inv <- n.inv.start[1]
    change <- 1
    
    while(change > 0.1){
      n.update <- pop_interactions(N0 = n.old, param = p.ave)
      n.per.total <- sum(n.update[sp.invader])
      n.update[sp.invader] <- n.update[sp.invader]/n.per.total
      n.update[sp.resident] <- n.old[sp.resident]
      n.old <- n.update
      
      n.new.inv <- n.update[sp.invader]
      change <- abs(n.old.inv - n.new.inv[1])
      n.old.inv <- n.new.inv[1]
    }
  } 
  
  # running the resident and invader for the remaining time steps
  for (t in (init.time.steps+1):(total.time.steps-1)){
    # parameters for the varying env condition
    p.env <- parameters %>% filter(treatment == env.cond[t])
    
    # setting non-varying parameters to their average
    if(vary.lambda == FALSE){
      p.env$lambda <- p.ave$lambda
    }
    
    #NOTE: not sure if this is working yet
    if(vary.alpha == FALSE){
      alpha.columns <- c(paste('a', sp.invader, sep = '.'), paste('a', sp.resident, sep = '.'))
      p.env[,alpha.columns] <- p.ave[,alpha.columns]
    }
    
    
    # running invader and resident together
    N0.together <- n.all[t,]
    
    # figuring out starting invader population distribution if the invader is perennial
    # starting from the n.old found for average conditions above
    if(length(sp.invader) > 1){
      change <- 1
      while(change > 0.01){
        n.update <- pop_interactions(N0 = n.old, param = p.env)
        n.per.total <- sum(n.update[sp.invader])
        n.update[sp.invader] <- n.update[sp.invader]/n.per.total
        n.update[sp.resident] <- n.old[sp.resident]
        n.old <- n.update
        n.new.inv <- n.update[sp.invader]
        change <- abs(n.old.inv - n.new.inv[1])
        n.old.inv <- n.new.inv[1]
      }
      N0.together[sp.invader] <- n.update[sp.invader] # using the equilibrium stage distribution from above
    } else {
      N0.together[sp.invader] <- 1 # if the invader has only one life stage
    }
    
    
    # running one time step with the appropriate environmental parameters
    n.res.impact <- pop_interactions(N0 = N0.together, param = p.env)
    
    # saving this output as the invader population and the impacted resident population
    n.all[t+1,sp.invader] <- n.res.impact[sp.invader]
    n.all[t+1,sp.res.impact] <- n.res.impact[sp.resident]
    
    # a version of this with the resident unaffected by the invader
    N0.res.only <- n.all[t,]
    N0.res.only[sp.invader] <- 0
    n.res.only <- pop_interactions(N0 = N0.res.only, param = p.env)
    n.all[t+1,sp.resident] <- n.res.only[sp.resident]
    
    # growth rate of the resident
    sp.res.gr <- paste(paste(sp.resident, collapse = '.'), 'gr', sep = '.') # column name
    n.all[t+1,sp.res.gr] <- sum(n.all[t+1,sp.res.impact])/sum(n.all[t,sp.resident])
    
    # growth rate of the invader
    sp.inv.gr <- paste(paste(sp.invader, collapse = '.'), 'gr', sep = '.') # column name
    n.all[t+1,sp.inv.gr] <- sum(n.all[t+1,sp.invader])
    
  }
  
  n.all$time <- 1:total.time.steps
  return(n.all)
  
}

```


Plotting function so we can visualize what's going on with the different types of variation
```{r plotting-function}
plot_invasion <- function(df){ # plots actual population sizes
  df.long <- df %>% 
    pivot_longer(cols = !c(time, ends_with('gr')),
                 names_to = 'species', values_to = 'n',
                 values_drop_na = TRUE) %>% 
    mutate(n.log = log(n))

  
  ggplot(df.long, aes(x = time, y = n.log, color = species)) +
    geom_line() +
    theme_cw() +
    xlab('Time') + 
    ylab('Population size (log)')
  
}

plot_gr <- function(df) { # plots population growth rates
  df.long <- df %>% 
    pivot_longer(cols = ends_with('gr'),
                 names_to = 'species', values_to = 'n',
                 values_drop_na = TRUE) %>% 
    mutate(n.log = log(n))
  
  
  ggplot(df.long, aes(x = time, y = n.log, color = species)) +
    geom_line() +
    theme_cw() +
    xlab('Time') + 
    ylab('Growth Rate (log)')
}
```

*NEXT STEP is to get the partition function working--but first to figure out how the growth rates of the perennial seedlings and adults translates to the growth rate of the perennial population as a whole*

# Running and plotting invasions

Full variation (normal run)
```{r normal-run}
time.warm.up <- 50
time.full <- 100

# two equally probable environmental conditions
env.draw <- rbinom(time.full, 1, 0.5) 
env.condition <- if_else(env.draw > 0, 'wet','dry')
  
invade.per.full <-  run_invasion(sp.invader = c('s','p'), sp.resident = 'an', N0.r = 100, 
                         parameters = pars, env.cond = env.condition,
                         vary.lambda = TRUE, vary.alpha = TRUE, 
                         init.time.steps = time.warm.up, total.time.steps = time.full)

plot_invasion(invade.per.full)
plot_gr(invade.per.full)



invade.an.full <-  run_invasion(sp.invader = 'an', sp.resident = c('s','p'), N0.r = 10, 
                         parameters = pars, env.cond = env.condition,
                         vary.lambda = TRUE, vary.alpha = TRUE, 
                         init.time.steps = time.warm.up, total.time.steps = time.full)

plot_invasion(invade.an.full)
plot_gr(invade.an.full)

```