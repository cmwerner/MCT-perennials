---
title: "Partitioning seedbank annual - nonseedbank annual"
output: html_document
---

Goal is to look at the strength of the storage effect in seedbanking annual (AS) and nonseedbanking annual (AN) species interactions. We want to measure how the storage effect [and the relative strength of storage effect:relative nonlinearity] changes with 1. magnitude of envrionmental variation 2. autocorrelation of environmental variation

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

## Personal ggplot theme
theme_cw <- function () { 
  theme_bw(base_size=12) %+replace% 
    theme(
      panel.background = element_blank(), 
      plot.background = element_blank(), 
      axis.ticks = element_line(colour = "grey70", size = rel(0.5)),
      panel.grid.minor = element_blank(), 
      panel.grid.major.x = element_blank(),
      legend.background = element_blank(), 
      legend.key = element_blank(),
      strip.background = element_blank(), 
    #  strip.text=element_text(size=12),
    #  axis.text=element_text(size=12),
      complete = TRUE
    )
}
```

## Parameters and set up
Setting parameters we're going to use for alpha and lambda under different environmental conditions. Starting with the lambda and alpha parameters for an (as our AN) and as (as our AS) from Hallett et al. 2019 Ecology Letters paper, using the "wet" treatment as our wet environment and the "dry" treatment for our dry environment. Also going to use the seedbank parameters for as listed in that ms, which references Rice 1985, and simplifying the an to being non-seedbanking (so shifting its survival in the seed bank proportion from 0.4 to 0)

```{r parameters}

# seed survival and germination fractions
# don't currently differ by environmental conditions but they could
as <- 0 # changed to 0 to be a fully non-seedbanking species
ag <- 0.9
es <- 0.82
eg <- 0.6

# main parameters
pars <- read.csv('model_parameters_hallett.csv') %>%
  mutate(species = ifelse(species == 'Avena', 'an', 'as'), # generalize species names
         treatment = ifelse(treatment == 'consistentDry','dry','wet')) %>%
  rename(a.an = aiA, a.as = aiE) %>%
  select(-X) %>%
  mutate(seed.surv = ifelse(species == 'an', as, es),
         seed.germ = ifelse(species == 'an', ag, eg)) # add seed survival and germ columns

# adding average values to the parameter df
an.means <- pars %>%
  filter(species == 'an') %>% 
  select(a.an, a.as, lambda) %>%
  colMeans()
as.means <- pars %>%
  filter(species == 'as') %>% 
  select(a.an, a.as, lambda) %>%
  colMeans()
pars <- pars %>%
  add_row(treatment = 'average', species = 'an', 
          a.an = an.means['a.an'], a.as = an.means['a.as'], lambda = an.means['lambda']) %>%
  add_row(treatment = 'average', species = 'as', 
          a.an = an.means['a.an'], a.as = an.means['a.as'], lambda = an.means['lambda'])
```

Functions for coexistence calculations (currently taken from Hallett et al 2019)

```{r functions-coexistence}
# Determine equilibrium conditions for each species in isolation 
pop_equilibrium <- function (N0, s, g, a.intra, lambda) {
  # to run for only a single timestep
  N <- s*(1-g)*N0 + N0*(lambda*g)/(1+a.intra*N0)
  return(N)
}

# invader population growth rate one time step forward
pop_invade <- function (N0, resident, s, g, a.inter, lambda) {
  # to run for only a single timestep
  N <- s*(1-g)*N0 + N0*(lambda*g)/(1+a.inter*resident)
  return(N)
}

# resident population growth rate one time step forward
pop_resident <- function (N0, resident, s, g, a.intra, a.inter, lambda) {
  # to run for only a single timestep
  N <- s*(1-g)*resident + resident*(lambda*g)/(1+a.intra*resident+a.inter*N0)
  return(N)
}
```

## Running models
Function to run an invasion one way: resident only for init.time.steps, invader added in after that until total.time.steps. Returns a list? with initial resident growth, invader growth, and resident growth -- could also make this as a df/tibble with columns for species, and the invader would just start after a certain time point. 
```{r running-invasion}
run_invasion <- function(sp.invader, sp.resident, N0.i, N0.r, parameters, vary.lambda = TRUE, vary.alpha = TRUE, init.time.steps = 50, total.time.steps = 100){
  
  # two equally probable environmental conditions
  env.draw <- rbinom(total.time.steps, 1, 0.5) 
  env.cond <- if_else(env.draw > 0, 'wet','dry')
  
  n.res <- rep(NA, total.time.steps) # resident population
  n.res.gr <- rep(NA, total.time.steps) # growth rate of resident population
  n.inv <- rep(NA, total.time.steps) # invader population, init.time.steps will stay NA
  
  a.res <- paste('a',sp.resident, sep = '.') # column name of resident interactions
  a.inv <- paste('a',sp.invader, sep = '.') # column name of invader interactions
  
  # parameters for average environmental condition
  p.res.ave <- parameters %>% filter(species == sp.resident, treatment == 'average')
  p.inv.ave <- parameters %>% filter(species == sp.invader, treatment == 'average')
    
  # running just the resident alone for init.time.steps
  n.res[1] <- N0.r
  for (t in 1:init.time.steps){
    # parameters for varying environmental condition
    p.res <- parameters %>% filter(species == sp.resident, treatment == env.cond[t])
    
    # running one time step using the appropriate environmental parameters
    n.res[t+1] <- pop_equilibrium(N0 = n.res[t], 
                                  s = p.res$seed.surv, 
                                  g = p.res$seed.germ, 
                                  lambda = if_else(vary.lambda == TRUE,
                                                   p.res$lambda, 
                                                   p.res.ave$lambda), 
                                  a.intra = if_else(vary.alpha == TRUE,
                                                    p.res[,a.res],
                                                    p.res.ave[,a.res]))
    n.res.gr[t+1] <- n.res[t+1]/n.res[t]
  }
  
  # running the resident and invader for the remaining time steps
  for (t in (init.time.steps+1):(total.time.steps-1)){
    p.res <- parameters %>% filter(species == sp.resident, treatment == env.cond[t])
    p.inv <- parameters %>% filter(species == sp.invader, treatment == env.cond[t])
    
    # invader population
    # N0 of the invader is set to the same value each time
    n.inv[t+1] <- pop_invade(N0 = N0.i, 
                             resident = n.res[t], 
                             s = p.inv$seed.surv, 
                             g = p.inv$seed.germ, 
                             lambda = if_else(vary.lambda == TRUE,
                                              p.inv$lambda, 
                                              p.inv.ave$lambda), 
                             a.inter = if_else(vary.alpha == TRUE,
                                               p.inv[,a.res],
                                               p.inv.ave[,a.res]))
    # resident population
    n.res[t+1] <- pop_resident(N0 = N0.i, 
                               resident = n.res[t], 
                               s = p.res$seed.surv, 
                               g = p.res$seed.germ, 
                               lambda = if_else(vary.lambda == TRUE,
                                                p.res$lambda, 
                                                p.res.ave$lambda), 
                               a.intra = if_else(vary.alpha == TRUE,
                                                 p.res[,a.res],
                                                 p.res.ave[,a.res]),
                               a.inter = if_else(vary.alpha == TRUE,
                                                 p.res[,a.inv],
                                                 p.res.ave[,a.inv]))
    n.res.gr[t+1] <- n.res[t+1]/n.res[t]
  }

  return(tibble(time = 1:total.time.steps, env.cond, n.inv, n.res, n.res.gr))
}

```

Plotting function so we can visualize what's going on with the different types of variation
```{r plotting-function}
plot_invasion <- function(df, sp.invader, sp.resident, title){
  df.long <- df %>% 
    pivot_longer(cols = c(n.res, n.inv),
                 names_to = 'species', values_to = 'n') %>% 
    mutate(n.log = log(n))
  
  ## colors for graphs
  cols <- c(
    as = "#5445b1",
    an = "#f3c483",
    p = "#4DA896",
    lines = "#749dae"
  )
  
  sp.inv.cap <- toupper(sp.invader)
  sp.res.cap <- toupper(sp.resident)
  
  ggplot(df.long, aes(x = time, y = n.log, color = species)) +
    geom_line() +
    geom_vline(xintercept = time.warm.up, color = cols[['lines']], linetype = 'dashed') +
    theme_cw() +
    scale_color_manual(name = 'Species', values = c(cols[[sp.invader]], cols[[sp.resident]]),
                       labels = c(sp.inv.cap,sp.res.cap)) +
    ggtitle(paste(title, sp.inv.cap, 'invades', sp.res.cap, sep = ' ')) +
    xlab('Time') + 
    ylab('Population size (log)')
  
}
```

# Calculating partitions
Function to calculate partitions for a given invader and resident
```{r partition-function}
partition_epsilons <- function(sp.inv, sp.res){
  
  part <- tibble(sp.invader = sp.inv, sp.resident = sp.res)
  
  # no variation
  invade.none <-  run_invasion(sp.invader = sp.inv, sp.resident = sp.res,
                               N0.i = 1, N0.r = 100, parameters = pars,
                               init.time.steps = time.warm.up, total.time.steps = time.full,
                               vary.lambda = FALSE, vary.alpha = FALSE) %>%
    filter(time > time.warm.up + 1)
  
  part$inv.e0 <- log(mean(invade.none$n.inv))
  part$res.e0 <- log(mean(invade.none$n.res.gr))
  
  # lambda variation only
  invade.l <-  run_invasion(sp.invader = sp.inv, sp.resident = sp.res,
                            N0.i = 1, N0.r = 100, parameters = pars,
                            init.time.steps = time.warm.up, total.time.steps = time.full,
                            vary.lambda = TRUE, vary.alpha = FALSE) %>%
    filter(time > time.warm.up + 1)
  
  part$inv.el <- log(mean(invade.l$n.inv)) - part$inv.e0
  part$res.el <- log(mean(invade.l$n.res.gr))- part$inv.e0
  
  # alpha variation only
  invade.a <-  run_invasion(sp.invader = sp.inv, sp.resident = sp.res,
                            N0.i = 1, N0.r = 100, parameters = pars,
                            init.time.steps = time.warm.up, total.time.steps = time.full,
                            vary.lambda = FALSE, vary.alpha = TRUE) %>%
    filter(time > time.warm.up + 1)
  
  part$inv.ea <- log(mean(invade.a$n.inv)) - part$inv.e0
  part$res.ea <- log(mean(invade.a$n.res.gr)) - part$inv.e0
  
  # full variation
  invade.full <-  run_invasion(sp.invader = sp.inv, sp.resident = sp.res,
                               N0.i = 1, N0.r = 100, parameters = pars,
                               init.time.steps = time.warm.up, total.time.steps = time.full) %>%
    filter(time > time.warm.up + 1)
  
  part$inv.full <- log(mean(invade.full$n.inv)) 
  part$res.full <- log(mean(invade.full$n.res.gr))
  part$inv.eint <- part$inv.full - (part$inv.e0 + part$inv.el + part$inv.ea)
  part$res.eint <- part$res.full - (part$res.e0 + part$res.el + part$res.ea)
  
  return(part)
}


```

Running that partition function
```{r partition-run}
time.warm.up <- 50
time.full <- 100

partitions <- partition_epsilons('an','as') %>%
  rbind(partition_epsilons('as','an')) %>%
  pivot_longer(cols = inv.e0:res.eint) %>%
  separate(name, into = c('player', 'partition')) %>%
  pivot_wider(names_from = player, values_from = value) %>%
  mutate(delta = inv - res,
         partition = factor(partition, 
                            levels = c('full','e0','ea','el','eint')))

ggplot(partitions, aes(x = partition, y = delta)) + 
  facet_grid(cols = vars(sp.invader)) + 
  geom_bar(stat = 'identity', position = position_dodge()) +
  theme_cw()

```


# Running and plotting invasions

Full variation (normal run)
```{r normal-run}
time.warm.up <- 50
time.full <- 100
invade.an.full <-  run_invasion(sp.invader = 'an', sp.resident = 'as',
                                N0.i = 1, N0.r = 100, parameters = pars,
                                init.time.steps = time.warm.up, total.time.steps = time.full)

plot_invasion(invade.an.full, 'an', 'as', 'Full variation')


invade.as.full <-  run_invasion(sp.invader = 'as', sp.resident = 'an',
                                N0.i = 1, N0.r = 100, parameters = pars,
                                init.time.steps = time.warm.up, total.time.steps = time.full)

plot_invasion(invade.as.full, 'as', 'an', 'Full variation')

```

No variation
```{r no-variation}
invade.an.none <-  run_invasion(sp.invader = 'an', sp.resident = 'as',
                           N0.i = 1, N0.r = 100, parameters = pars,
                           init.time.steps = time.warm.up, total.time.steps = time.full,
                           vary.lambda = FALSE, vary.alpha = FALSE)

plot_invasion(invade.an.none, 'an', 'as', 'No variation')

invade.as.none <-  run_invasion(sp.invader = 'as', sp.resident = 'an',
                           N0.i = 1, N0.r = 100, parameters = pars,
                           init.time.steps = time.warm.up, total.time.steps = time.full,
                           vary.lambda = FALSE, vary.alpha = FALSE)

plot_invasion(invade.as.none, 'as', 'an', 'No variation')
```

Lambda only
```{r lambda-variation}
invade.an.l <-  run_invasion(sp.invader = 'an', sp.resident = 'as',
                           N0.i = 1, N0.r = 100, parameters = pars,
                           init.time.steps = time.warm.up, total.time.steps = time.full,
                           vary.lambda = TRUE, vary.alpha = FALSE)

plot_invasion(invade.an.l, 'an', 'as', 'Lambda variation')


invade.as.l <-  run_invasion(sp.invader = 'as', sp.resident = 'an',
                           N0.i = 1, N0.r = 100, parameters = pars,
                           init.time.steps = time.warm.up, total.time.steps = time.full,
                           vary.lambda = TRUE, vary.alpha = FALSE)

plot_invasion(invade.as.l, 'as', 'an', 'Lambda')

```

Alpha only
```{r lambda-variation}
invade.an.a <-  run_invasion(sp.invader = 'an', sp.resident = 'as',
                           N0.i = 1, N0.r = 100, parameters = pars,
                           init.time.steps = time.warm.up, total.time.steps = time.full,
                           vary.lambda = FALSE, vary.alpha = TRUE)

plot_invasion(invade.an.a, 'an', 'as', 'Alpha variation')

invade.as.a <-  run_invasion(sp.invader = 'as', sp.resident = 'an',
                           N0.i = 1, N0.r = 100, parameters = pars,
                           init.time.steps = time.warm.up, total.time.steps = time.full,
                           vary.lambda = FALSE, vary.alpha = TRUE)

plot_invasion(invade.as.a, 'as', 'an', 'Alpha variation')

```


